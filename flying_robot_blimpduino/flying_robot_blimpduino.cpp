//////////////////////////////////////////////////////////////////////////
// Auto-generated by RAD
//////////////////////////////////////////////////////////////////////////
#include <WProgram.h>

#include <SoftwareSerial.h>

#include <Wire.h>
#include <Servo.h>
#define MAX_SPEED 127
//////////////////////////////////////////////////////////////////////////
// plugin directives
//////////////////////////////////////////////////////////////////////////
#define FORWARD 1
#define REVERSE 0
//////////////////////////////////////////////////////////////////////////
// method signatures
//////////////////////////////////////////////////////////////////////////
void loop();
void setup();
// sketch signatures
int main();
int battery();
int right_motor();
int right_speed();
int left_motor();
int left_speed();
Servo& vectoring_servo();
// plugin signatures





//////////////////////////////////////////////////////////////////////////
// plugin structs
//////////////////////////////////////////////////////////////////////////
void loop();
void hail();
void status();
void elevators();
void rudder();
void throttle();
void instruments();
void autopilot();
void set_thrusters();
void activate_thrusters();
void calculate_motor_speeds();
long adjusted_throttle_speed();
long hard_turn_throttle_speed();
void check_battery_voltage();
void handle_autopilot_update();

//////////////////////////////////////////////////////////////////////////
// plugin external variables
//////////////////////////////////////////////////////////////////////////
float average_battery = 0.0;
bool battery_init_completed;
bool current_command_received_complete;
int current_command_length;
char command_buffer[120];
char command_code[1];
char direction_code[1];
char instrument_code[1];
char autopilot_code[1];
int command_value;
char elevator_direction[1];
int elevator_deflection = 0;
char rudder_direction[1];
int rudder_deflection = 0;
char throttle_direction[1];
int throttle_speed = 0;
bool autopilot_engaged;
int HMC6352Address = 0x42;
byte headingData[2];
int headingValue = 0;
int slaveAddress = HMC6352Address >> 1;

//////////////////////////////////////////////////////////////////////////
// sketch external variables
//////////////////////////////////////////////////////////////////////////
long __deflection_percent = 0;
byte __right_direction = 1;
unsigned long __last_autopilot_update = 0;
byte __forward = 1;
byte __deflection = 0;
byte __left_direction = 1;
unsigned long __autopilot_update_frequency = 500;
long __right_motor_speed = 0;
byte __direction = 1;
long __deflection_val = 0;
long __left_motor_speed = 0;
byte __reverse = 0;

// servo_settings array

// debounce array

// hysteresis array

// spectrasymbol soft pot array


//////////////////////////////////////////////////////////////////////////
// variable and accessors
//////////////////////////////////////////////////////////////////////////
int _battery = 0;
int _right_motor = 2;
int _right_speed = 3;
int _left_motor = 4;
int _left_speed = 5;
Servo _vectoring_servo = Servo();
void servo_refresh(void);

int battery() {
	return _battery;
}
int right_motor() {
	return _right_motor;
}
int right_speed() {
	return _right_speed;
}
int left_motor() {
	return _left_motor;
}
int left_speed() {
	return _left_speed;
}
        Servo& vectoring_servo() {
          return _vectoring_servo;
        }
        uint8_t attach( Servo& s, int p ) {
          return s.attach(p);
        }
        uint8_t attach( Servo& s, int p, int pos ) {
          return s.attach(p, pos );
        }
        uint8_t attach( Servo& s, int p, uint16_t mn, uint16_t mx ) {
          return s.attach(p, mn, mx);
        }
        uint8_t attach( Servo& s, int p, int pos, uint16_t mn, uint16_t mx ) {
          return s.attach(p, pos, mn, mx);
        }
        void detach( Servo& s ) {
          return s.detach();
        }
        void position( Servo& s, int b ) {
          return s.position( b );
        }
        void speed( Servo& s, int b ) {
          return s.speed( b );
        }
        uint8_t read( Servo& s ) {
          return s.read();
        }
        uint8_t attached( Servo& s ) {
          return s.attached();
        }
        static void refresh( Servo& s ) {
          return s.refresh();
        }


//////////////////////////////////////////////////////////////////////////
// assembler declarations
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// setup
//////////////////////////////////////////////////////////////////////////
void setup() {
	// pin modes
	pinMode(0, INPUT);
	pinMode(2, OUTPUT);
	pinMode(3, OUTPUT);
	pinMode(4, OUTPUT);
	pinMode(5, OUTPUT);
	pinMode(11, OUTPUT);
	digitalWrite( 0, HIGH ); // enable pull-up resistor for input
	// setup from plugins via add_to_setup method
	battery_init_completed = false;
	current_command_received_complete = false; elevator_direction[0] = 'c'; rudder_direction[0] = 'c'; throttle_direction[0] = 'f'; autopilot_engaged = false;
	// other setup
Serial.begin(19200);
	_vectoring_servo.attach(11, 544, 2400);
}

//////////////////////////////////////////////////////////////////////////
// helper methods
//////////////////////////////////////////////////////////////////////////

// RAD built-in helpers
void servo_refresh(void)
{
	Servo::refresh();
}

//////////////////////////////////////////////////////////////////////////
// plugin methods
//////////////////////////////////////////////////////////////////////////
void battery_test() {
  }

  // initialize the battery reading
  void init_battery(int pin) {
    average_battery = analogRead(pin);
  }

  // get the current voltage
  // TODO: allow user to set constants for different expected battery voltages
  float voltage(int pin)
  {
    if (! battery_init_completed) {
      init_battery(pin);
    }
    
    average_battery=(((float) average_battery * 0.99) + (float)((float) analogRead(pin) * 0.01)); // Jordi called it dynamic average

    float battery_voltage=(float)((float) average_battery * (float)4.887586) * (float)2; // converting values to millivolts..,

    return battery_voltage ;
  }

void be_flying_robot(){}
  
  boolean current_command_received_is_complete() {
    return current_command_received_complete == true ;
  }
  
  char current_command() {
    return command_code[0];
  }

  char current_command_direction() {
    return direction_code[0];
  }

  char current_command_instrument() {
    return instrument_code[0];
  }

  char current_command_autopilot() {
    return autopilot_code[0];
  }
  
  int current_command_value() {
    return command_value ;
  }
  
  char current_elevator_direction() {
    return elevator_direction[0];
  }
  
  int current_elevator_deflection() {
    return elevator_deflection ;
  }

  char current_rudder_direction() {
    return rudder_direction[0];
  }
  
  int current_rudder_deflection() {
    return rudder_deflection ;
  }

  char current_throttle_direction() {
    return throttle_direction[0];
  }
  
  int current_throttle_speed() {
    return throttle_speed ;
  }
  
  boolean is_autopilot_on() {
    return autopilot_engaged == true ;
  }
  
  void autopilot_on() {
    autopilot_engaged = true;
  }

  void autopilot_off() {
    autopilot_engaged = false;
  }
  
  void clear_command_buffer() {
    for(int i=0; i<120; i++){
      command_buffer[i] = 0 ;
    }
    
    command_code[0] = 0 ;
    direction_code[0] = 0 ;
    instrument_code[0] = 0 ;
    current_command_length = 0 ;
    current_command_received_complete = false ;
  }
  
  void parse_command_code() {
    if(current_command_length == 0) {
      command_code[0] = 0;
    } else {
      command_code[0] = command_buffer[0];
    }
  }

  void parse_direction_code() {
    if(current_command_length >= 3) {
      direction_code[0] = command_buffer[2];
    } else {
      direction_code[0] = 0;
    }
  }

  void parse_instrument_code() {
    if(current_command_length >= 3) {
      instrument_code[0] = command_buffer[2];
    } else {
      instrument_code[0] = 0;
    }
  }

  void parse_autopilot_code() {
    if(current_command_length >= 3) {
      autopilot_code[0] = command_buffer[2];
    } else {
      autopilot_code[0] = 0;
    }
  }

  void parse_command_value(int start) {
    if(current_command_length >= start + 1) {
      command_value = atoi(command_buffer + start);
    } else {
      command_value = 0 ;
    }
  }
  
  void get_command() {
    if(current_command_received_complete) {
      clear_command_buffer();
    }
    
    while(Serial.available() > 0) {
      command_buffer[current_command_length] = Serial.read();
      if(command_buffer[current_command_length] == '\r') {
        current_command_received_complete = true ;
        parse_command_code();
        return;
      } else {
        current_command_length++ ;
      }
    }
  }
  
  // used to echo the commands being received via serial
  void print_current_command(const char* cmd, int val) {
    Serial.print(cmd);
    Serial.print(" command - direction:");
    Serial.print(current_command_direction());
    Serial.print(" value:");
    Serial.println(val);    
  }
  
  void dispatch_command() {
    if(!current_command_received_is_complete()) {
      return;
    }
    
    char cmd = current_command(); 
    
    if (cmd == 'h') {
      hail();
    } else if (cmd == 's') {  
      status();
    } else if (cmd == 'e') {
      parse_direction_code();
      parse_command_value(4);
      elevator_direction[0] = current_command_direction();
      elevator_deflection = current_command_value();
      if (elevator_deflection > 90) {
        elevator_deflection = 90 ;
      }
      
      elevators();
    } else if (cmd == 'r') { 
      parse_direction_code();
      parse_command_value(4);
      rudder_direction[0] = current_command_direction();
      rudder_deflection = current_command_value();
      if (rudder_deflection > 90) {
        rudder_deflection = 90 ;
      }
      
      rudder();
    } else if (cmd == 't') {
      parse_direction_code();
      parse_command_value(4);
      throttle_direction[0] = current_command_direction();
      throttle_speed = current_command_value();
      if (throttle_speed > 100) {
        throttle_speed = 100 ;
      }
      
      throttle();
    } else if (cmd == 'i') {    
      parse_instrument_code();
      instruments();
    } else if (cmd == 'a') {    
      parse_autopilot_code();
      if (autopilot_code[0] == '0') {
        autopilot_off();
      }
        
      autopilot();
    } else {    
      Serial.println("Invalid command");
    }    
  }
  
  void process_command() {
    get_command();
    dispatch_command();
  }

void prepare_compass() {
    // hack to reference plugin, copied this trick from twitter plugin 
  }
  
  // The whole number part of the heading
  int heading()
  {
    return int (headingValue / 10) ;
  }
  
  // The fractional part of the heading
  int heading_fractional()
  {
    return int (headingValue % 10) ;
  }
  
  void read_compass()
  {
    // Send a "A" command to the HMC6352
    // This requests the current heading data
    Wire.beginTransmission(slaveAddress);
    Wire.send("A");              // The "Get Data" command
    Wire.endTransmission();
    delay(10);                   // The HMC6352 needs at least a 70us (microsecond) delay
    // after this command.  Using 10ms just makes it safe
    // Read the 2 heading bytes, MSB first
    // The resulting 16bit word is the compass heading in 10ths of a degree
    // For example: a heading of 1345 would be 134.5 degrees
    Wire.requestFrom(slaveAddress, 2);        // Request the 2 byte heading (MSB comes first)
    int i = 0;
    while(Wire.available() && i < 2)
    { 
      headingData[i] = Wire.receive();
      i++;
    }
    headingValue = headingData[0]*256 + headingData[1];  // Put the MSB and LSB together
  }

void L293_send_command(int directionPin, int speedPin, byte direction, byte speed)
  {
    direction = constrain(direction, 0, 1);
    speed = 250 - constrain(speed, 0, 127);

    if (direction == FORWARD) {
      digitalWrite(directionPin, LOW);
      analogWrite(speedPin, speed);
    } else {
      digitalWrite(directionPin, HIGH);
      analogWrite(speedPin, speed);
    }
  }


// serial helpers
int serial_available() {
          return (Serial.available() > 0);
        }
        
        char serial_read() {
          return (char) Serial.read();
        }
        
        void serial_flush() {
          return Serial.flush();
        }

        void serial_print( char str ) {
          return Serial.print( str );
        }

        void serial_print( char* str ) {
          return Serial.print( str );
        }

        void serial_print( int i ) {
          return Serial.print( i );
        }

        void serial_print( long i ) {
          return Serial.print( i );
        }

      	void serial_println( char* str ) {
          return Serial.println( str );
        }

        void serial_println( char str ) {
          return Serial.println( str );
        }

      	void serial_println( int i ) {
          return Serial.println( i );
        }

        void serial_println( long i ) {
          return Serial.println( i );
        }

        void serial_print( unsigned long i ) {
          return Serial.print( i );
        }


//////////////////////////////////////////////////////////////////////////
// main() function
//////////////////////////////////////////////////////////////////////////
int main() {
	init();
	setup();
	for( ;; ) { loop(); }
	return 0;
}

//////////////////////////////////////////////////////////////////////////
// loop!  Autogenerated by RubyToC, sorry it's ugly.
//////////////////////////////////////////////////////////////////////////
void
loop() {
be_flying_robot();
battery_test();
handle_autopilot_update();
process_command();
servo_refresh();
}
void
hail() {
serial_println("Roger");
}
void
status() {
serial_println("Status: operational");
check_battery_voltage();
}
void
elevators() {
print_current_command("Elevators", current_elevator_deflection());
if (current_elevator_direction() == 'c') {
__deflection = 90;
};
if (current_elevator_direction() == 'u') {
__deflection = 90 - current_elevator_deflection();
};
if (current_elevator_direction() == 'd') {
__deflection = 90 + current_elevator_deflection();
};
if (__deflection < 45) {
__deflection = 45;
};
if (__deflection > 135) {
__deflection = 135;
};
servo_refresh();
position(vectoring_servo(), __deflection);
}
void
rudder() {
print_current_command("Rudder", current_rudder_deflection());
set_thrusters();
}
void
throttle() {
print_current_command("Throttle", current_throttle_speed());
set_thrusters();
}
void
instruments() {
serial_print("Instruments command - request:");
serial_println(current_command_instrument());
}
void
autopilot() {
long throttle_speed;
if (current_command_autopilot() == '0') {
throttle_speed = 0;
set_thrusters();
serial_println("Autopilot Is Off");
};
if (current_command_autopilot() == '1') {
autopilot_on();
serial_println("Autopilot Is On");
}
}
void
set_thrusters() {
if (current_throttle_direction() == 'f') {
__left_direction = __forward;
__right_direction = __forward;
} else {
__left_direction = __reverse;
__right_direction = __reverse;

};
calculate_motor_speeds();
activate_thrusters();
}
void
activate_thrusters() {
L293_send_command(left_motor(), left_speed(), __left_direction, __left_motor_speed);
L293_send_command(right_motor(), right_speed(), __right_direction, __right_motor_speed);
}
void
calculate_motor_speeds() {
if (current_rudder_direction() == 'c') {
__left_motor_speed = current_throttle_speed() / 100.0 * MAX_SPEED;
__right_motor_speed = current_throttle_speed() / 100.0 * MAX_SPEED;
};
if (current_rudder_direction() == 'l') {
if (current_rudder_deflection() >= 45) {
if (current_throttle_direction() == 'f') {
__left_direction = __reverse;
} else {
__left_direction = __forward;
};
__left_motor_speed = hard_turn_throttle_speed() / 10000;
__right_motor_speed = current_throttle_speed() / 100.0 * MAX_SPEED;
} else {
__left_motor_speed = adjusted_throttle_speed() / 10000;
__right_motor_speed = current_throttle_speed() / 100.0 * MAX_SPEED;

}
};
if (current_rudder_direction() == 'r') {
if (current_rudder_deflection() >= 45) {
if (current_throttle_direction() == 'f') {
__right_direction = __reverse;
} else {
__right_direction = __forward;
};
__left_motor_speed = current_throttle_speed() / 100.0 * MAX_SPEED;
__right_motor_speed = hard_turn_throttle_speed() / 10000;
} else {
__left_motor_speed = current_throttle_speed() / 100.0 * MAX_SPEED;
__right_motor_speed = adjusted_throttle_speed() / 10000;

}
}
}
long
adjusted_throttle_speed() {
__deflection_percent = current_rudder_deflection() * 100 / 90;
__deflection_val = 100 - __deflection_percent;
return __deflection_val * current_throttle_speed() * MAX_SPEED;
}
long
hard_turn_throttle_speed() {
__deflection_percent = current_rudder_deflection() * 100 / 90;
return __deflection_percent * current_throttle_speed() * MAX_SPEED;
}
void
check_battery_voltage() {
serial_print("Battery voltage: ");
serial_println(int(voltage(battery())));
}
void
handle_autopilot_update() {
if (is_autopilot_on() && millis() - __last_autopilot_update > __autopilot_update_frequency) {
if (current_command_autopilot() == '1') {
if (heading() <= 330 && heading() >= 30) {
__left_direction = __forward;
__right_direction = __forward;
__left_motor_speed = 0;
__right_motor_speed = 0;
activate_thrusters();
};
if (heading() < 330 && heading() >= 270) {
__left_direction = __forward;
__right_direction = __reverse;
__left_motor_speed = 6;
__right_motor_speed = 6;
activate_thrusters();
};
if (heading() < 270 && heading() >= 180) {
__left_direction = __forward;
__right_direction = __reverse;
__left_motor_speed = 8;
__right_motor_speed = 8;
activate_thrusters();
};
if (heading() < 180 && heading() > 90) {
__left_direction = __reverse;
__right_direction = __forward;
__left_motor_speed = 8;
__right_motor_speed = 8;
activate_thrusters();
};
if (heading() <= 90 && heading() > 30) {
__left_direction = __reverse;
__right_direction = __forward;
__left_motor_speed = 6;
__right_motor_speed = 6;
activate_thrusters();
}
};
__last_autopilot_update = millis();
}
}
